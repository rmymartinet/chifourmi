import { Component, OnInit, OnDestroy, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { io, Socket } from 'socket.io-client';
import { environment } from '../environments/environment';

type CityType = 'bordeaux' | 'vienne' | 'france' | 'tunisie' | 'chelsea' | 'esperance';

interface Player {
  id: string;
  name: string;
  city: CityType;
}

interface GameTheme {
  name: string;
  cities: {
    city1: { name: string; emoji: string; color: string };
    city2: { name: string; emoji: string; color: string };
  };
  specialMessage?: string;
  winnerMessage?: string;
}

interface GameState {
  players: { [socketId: string]: Player };
  currentRound: number;
  maxRounds: number;
  scores: { [key: string]: number };
  roundInProgress: boolean;
  choices: { [socketId: string]: string };
  winner: string | null;
  theme?: string;
}

interface RoundResult {
  round: number;
  choices: { [key: string]: { player: string; choice: string } };
  winner: string;
  scores: { [key: string]: number };
}

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './app.html',
  styleUrls: ['./app.css']
})
export class AppComponent implements OnInit, OnDestroy {
  private socket: Socket;
  
  // √âtat de connexion
  isConnected = false;
  isConnecting = false;
  errorMessage = '';
  
  // Donn√©es du joueur
  playerName = '';
  selectedCity: CityType | '' = '';
  playerId = '';
  
  // Th√®me du jeu
  currentTheme: GameTheme = this.getDefaultTheme();
  
  // √âtat du jeu
  players: { [key: string]: Player } = {};
  scores: { [key: string]: number } = {};
  currentRound = 0;
  gameFinished = false;
  finalWinner = '';
  
  // √âtat de la manche
  roundWinner = '';
  lastRoundResult: RoundResult | null = null;
  waitingChoices: { [key: string]: boolean } = {};
  
  constructor(private cdr: ChangeDetectorRef) {
    this.socket = io(environment.socketUrl, {
      transports: ['websocket', 'polling'],
      timeout: 20000,
      forceNew: true
    });
    console.log('üîå Connecting to:', environment.socketUrl);
    console.log('üåç Environment:', environment);
  }

  private getDefaultTheme(): GameTheme {
    return {
      name: 'default',
      cities: {
        city1: { name: 'France', emoji: 'üá´üá∑', color: 'blue' },
        city2: { name: 'Tunisie', emoji: 'üáπüá≥', color: 'red' }
      }
    };
  }

  private getThemeForPlayers(): GameTheme {
    // Inclure le nom du joueur local aussi
    const allNames = [this.playerName, ...Object.values(this.players).map(p => p.name)];
    const playerNames = allNames.map(name => name.toLowerCase()).filter(name => name);
    
    if (playerNames.includes('maria')) {
      return {
        name: 'romantic',
        cities: {
          city1: { name: 'Bordeaux', emoji: 'üç∑', color: 'red' },
          city2: { name: 'Vienne', emoji: 'üéº', color: 'purple' }
        },
        specialMessage: 'R√©my je t\'aime',
        winnerMessage: 'vienne'
      };
    }
    
    if (playerNames.includes('sarra')) {
      return {
        name: 'tunisia-france',
        cities: {
          city1: { name: 'France', emoji: 'üá´üá∑', color: 'blue' },
          city2: { name: 'Tunisie', emoji: 'üáπüá≥', color: 'red' }
        },
        specialMessage: 'La Tunisie perd encore une fois !',
        winnerMessage: 'france'
      };
    }
    
    return this.getDefaultTheme();
  }

  private updateTheme() {
    this.currentTheme = this.getThemeForPlayers();
    this.initializeScoresForTheme();
  }

  private initializeScoresForTheme() {
    const cities = Object.keys(this.currentTheme.cities);
    this.scores = {};
    this.waitingChoices = {};
    
    if (this.currentTheme.name === 'romantic') {
      this.scores = { bordeaux: 0, vienne: 0 };
      this.waitingChoices = { bordeaux: false, vienne: false };
    } else if (this.currentTheme.name === 'tunisia-france') {
      this.scores = { france: 0, tunisie: 0 };
      this.waitingChoices = { france: false, tunisie: false };
    } else {
      this.scores = { france: 0, tunisie: 0 };
      this.waitingChoices = { france: false, tunisie: false };
    }
  }

  getCityOptions(): Array<{key: CityType, name: string, emoji: string}> {
    if (this.currentTheme.name === 'romantic') {
      return [
        { key: 'bordeaux' as CityType, name: 'Bordeaux', emoji: 'üç∑' },
        { key: 'vienne' as CityType, name: 'Vienne', emoji: 'üéº' }
      ];
    } else if (this.currentTheme.name === 'tunisia-france') {
      return [
        { key: 'france' as CityType, name: 'France', emoji: 'üá´üá∑' },
        { key: 'tunisie' as CityType, name: 'Tunisie', emoji: 'üáπüá≥' }
      ];
    } else {
      // Th√®me par d√©faut : France vs Tunisie
      return [
        { key: 'france' as CityType, name: 'France', emoji: 'üá´üá∑' },
        { key: 'tunisie' as CityType, name: 'Tunisie', emoji: 'üáπüá≥' }
      ];
    }
  }

  ngOnInit() {
    this.setupSocketListeners();
  }

  ngOnDestroy() {
    if (this.socket) {
      this.socket.disconnect();
    }
  }

  private setupSocketListeners() {
    this.socket.on('connect', () => {
      console.log('‚úÖ Connect√© au serveur WebSocket, ID:', this.socket.id);
      // Reset connection state si on √©tait en train de se connecter
      if (this.isConnecting) {
        console.log('üîÑ R√©initialisation √©tat de connexion');
      }
    });

    this.socket.on('connect_error', (error) => {
      console.error('‚ùå Erreur de connexion Socket.io:', error);
      this.isConnecting = false;
      this.showError('Erreur de connexion au serveur. V√©rifiez votre connexion.');
      this.cdr.detectChanges();
    });

    this.socket.on('disconnect', (reason) => {
      this.isConnected = false;
      console.log('‚ùå D√©connect√© du serveur:', reason);
    });

    this.socket.on('gameJoined', (data: { playerId: string; gameState: GameState }) => {
      console.log('üéâ Jeu rejoint avec succ√®s !', data);
      this.playerId = data.playerId;
      this.isConnected = true;
      this.isConnecting = false;
      this.updateGameState(data.gameState);
      this.clearError();
      this.cdr.detectChanges(); // Force la d√©tection de changement
      console.log('üîÑ Interface mise √† jour, isConnecting:', this.isConnecting);
    });

    this.socket.on('gameUpdate', (gameState: GameState) => {
      this.updateGameState(gameState);
      this.cdr.detectChanges();
    });

    this.socket.on('playerJoined', (player: Player) => {
      this.players[player.city] = player;
      this.cdr.detectChanges();
    });

    this.socket.on('playerLeft', (player: Player) => {
      delete this.players[player.city];
      this.cdr.detectChanges();
    });

    this.socket.on('choiceMade', (data: { city: string }) => {
      console.log('‚ö° Choix re√ßu pour', data.city);
      this.waitingChoices[data.city] = true;
      this.cdr.detectChanges();
    });

    this.socket.on('roundResult', (result: RoundResult) => {
      console.log('üéØ R√©sultat de manche re√ßu:', result);
      this.lastRoundResult = result;
      this.roundWinner = result.winner;
      this.scores = result.scores;
      this.waitingChoices = { bordeaux: false, vienne: false };
      this.cdr.detectChanges();
      
      // Effacer le r√©sultat apr√®s 3 secondes
      setTimeout(() => {
        this.roundWinner = '';
        this.lastRoundResult = null;
        this.cdr.detectChanges();
      }, 3000);
    });

    this.socket.on('gameFinished', (data: { winner: string; finalScores: any }) => {
      console.log('üèÜ Partie termin√©e:', data);
      console.log('üéØ finalWinner sera:', data.winner);
      this.gameFinished = true;
      this.finalWinner = data.winner;
      this.scores = data.finalScores;
      this.cdr.detectChanges();
      console.log('‚úÖ Interface mise √† jour - gameFinished:', this.gameFinished, 'finalWinner:', this.finalWinner);
    });

    this.socket.on('error', (message: string) => {
      console.log('‚ùå Erreur du serveur:', message);
      this.isConnecting = false;
      this.showError(message);
      this.cdr.detectChanges(); // Force la d√©tection de changement
    });
  }

  private updateGameState(gameState: GameState) {
    this.currentRound = gameState.currentRound;
    this.scores = gameState.scores;
    this.gameFinished = !!gameState.winner;
    this.finalWinner = gameState.winner || '';
    
    // Mettre √† jour les joueurs
    Object.values(gameState.players).forEach(player => {
      this.players[player.city] = player;
    });
    
    // Mettre √† jour le th√®me si n√©cessaire
    this.updateTheme();
  }

  onPlayerNameChange() {
    // Mettre √† jour le th√®me en fonction du nom
    this.updateTheme();
    // R√©initialiser la ville s√©lectionn√©e si elle n'est plus valide
    const validCities = this.getCityOptions().map(c => c.key);
    if (this.selectedCity && !validCities.includes(this.selectedCity as CityType)) {
      this.selectedCity = '';
    }
  }

  joinGame() {
    if (!this.playerName || !this.selectedCity || this.isConnecting) return;
    
    this.isConnecting = true;
    console.log('üöÄ Tentative de connexion...', { name: this.playerName, city: this.selectedCity });
    
    this.socket.emit('joinGame', {
      name: this.playerName,
      city: this.selectedCity
    });
    
    // Timeout de s√©curit√© au cas o√π le serveur ne r√©pond pas
    setTimeout(() => {
      if (this.isConnecting) {
        console.log('‚è∞ Timeout de connexion - √©tat socket:', this.socket.connected);
        this.isConnecting = false;
        this.showError('Connexion √©chou√©e. V√©rifiez que le serveur fonctionne.');
        this.cdr.detectChanges();
      }
    }, 5000);
  }

  makeChoice(choice: string) {
    if (!this.canPlay()) return;
    
    this.socket.emit('makeChoice', choice);
    
    // Marquer que ce joueur a fait son choix
    const playerCity = this.getPlayerCity();
    if (playerCity) {
      this.waitingChoices[playerCity] = true;
    }
  }

  newGame() {
    console.log('üîÑ Nouvelle partie demand√©e');
    this.socket.emit('newGame');
    this.gameFinished = false;
    this.finalWinner = '';
    this.roundWinner = '';
    this.lastRoundResult = null;
    this.waitingChoices = { bordeaux: false, vienne: false };
    this.cdr.detectChanges();
  }

  canPlay(): boolean {
    const playerCity = this.getPlayerCity();
    return playerCity ? !this.waitingChoices[playerCity] && !this.gameFinished : false;
  }

  private getPlayerCity(): CityType | null {
    for (const [city, player] of Object.entries(this.players)) {
      if (player.id === this.playerId) return city as CityType;
    }
    return null;
  }

  getChoiceEmoji(choice: string): string {
    switch (choice) {
      case 'pierre': return 'ü™®';
      case 'papier': return 'üìÑ';
      case 'ciseaux': return '‚úÇÔ∏è';
      default: return '‚ùì';
    }
  }

  getWinnerDisplayName(winner: string): string {
    const cityOption = this.getCityOptions().find(c => c.key === winner);
    return cityOption ? cityOption.name : winner;
  }

  shouldShowSpecialMessage(): boolean {
    if (!this.gameFinished || !this.currentTheme.specialMessage) return false;
    
    if (this.currentTheme.name === 'romantic') {
      return this.finalWinner === 'bordeaux'; // Si Maria (Vienne) perd
    }
    
    if (this.currentTheme.name === 'tunisia-france') {
      return this.finalWinner === 'france'; // Si Sarra (Tunisie) perd
    }
    
    return false;
  }

  private showError(message: string) {
    this.errorMessage = message;
    setTimeout(() => {
      this.errorMessage = '';
    }, 5000);
  }

  private clearError() {
    this.errorMessage = '';
  }
}
